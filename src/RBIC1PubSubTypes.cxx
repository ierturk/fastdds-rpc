// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file RBIC1PubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastddsgen.
 */


#include <fastdds/rtps/common/CdrSerialization.hpp>

#include "RBIC1PubSubTypes.h"
#include "RBIC1CdrAux.hpp"

using SerializedPayload_t = eprosima::fastrtps::rtps::SerializedPayload_t;
using InstanceHandle_t = eprosima::fastrtps::rtps::InstanceHandle_t;
using DataRepresentationId_t = eprosima::fastdds::dds::DataRepresentationId_t;

namespace RBIC1 {


    OutLinRequestPubSubType::OutLinRequestPubSubType()
    {
        setName("RBIC1::OutLinRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinRequest_max_key_cdr_typesize > 16 ? RBIC1_OutLinRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinRequestPubSubType::~OutLinRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinRequest* p_type = static_cast<OutLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinRequest* p_type = static_cast<OutLinRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinRequest());
    }

    void OutLinRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinRequest*>(data));
    }

    bool OutLinRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinRequest* p_type = static_cast<OutLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutLinReplyPubSubType::OutLinReplyPubSubType()
    {
        setName("RBIC1::OutLinReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinReply_max_key_cdr_typesize > 16 ? RBIC1_OutLinReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinReplyPubSubType::~OutLinReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinReply* p_type = static_cast<OutLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinReply* p_type = static_cast<OutLinReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinReply());
    }

    void OutLinReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinReply*>(data));
    }

    bool OutLinReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinReply* p_type = static_cast<OutLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    TLinRequestPubSubType::TLinRequestPubSubType()
    {
        setName("RBIC1::TLinRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(TLinRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_TLinRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_TLinRequest_max_key_cdr_typesize > 16 ? RBIC1_TLinRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    TLinRequestPubSubType::~TLinRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool TLinRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        TLinRequest* p_type = static_cast<TLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool TLinRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            TLinRequest* p_type = static_cast<TLinRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TLinRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TLinRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<TLinRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* TLinRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new TLinRequest());
    }

    void TLinRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<TLinRequest*>(data));
    }

    bool TLinRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        TLinRequest* p_type = static_cast<TLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_TLinRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_TLinRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    TLinReplyPubSubType::TLinReplyPubSubType()
    {
        setName("RBIC1::TLinReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(TLinReply::getMaxCdrSerializedSize());
    #else
            RBIC1_TLinReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_TLinReply_max_key_cdr_typesize > 16 ? RBIC1_TLinReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    TLinReplyPubSubType::~TLinReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool TLinReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        TLinReply* p_type = static_cast<TLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool TLinReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            TLinReply* p_type = static_cast<TLinReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TLinReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TLinReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<TLinReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* TLinReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new TLinReply());
    }

    void TLinReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<TLinReply*>(data));
    }

    bool TLinReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        TLinReply* p_type = static_cast<TLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_TLinReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_TLinReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadRequestPubSubType::OutQuadRequestPubSubType()
    {
        setName("RBIC1::OutQuadRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadRequest_max_key_cdr_typesize > 16 ? RBIC1_OutQuadRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadRequestPubSubType::~OutQuadRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadRequest* p_type = static_cast<OutQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadRequest* p_type = static_cast<OutQuadRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadRequest());
    }

    void OutQuadRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadRequest*>(data));
    }

    bool OutQuadRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadRequest* p_type = static_cast<OutQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadReplyPubSubType::OutQuadReplyPubSubType()
    {
        setName("RBIC1::OutQuadReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadReply_max_key_cdr_typesize > 16 ? RBIC1_OutQuadReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadReplyPubSubType::~OutQuadReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadReply* p_type = static_cast<OutQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadReply* p_type = static_cast<OutQuadReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadReply());
    }

    void OutQuadReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadReply*>(data));
    }

    bool OutQuadReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadReply* p_type = static_cast<OutQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutThirdRequestPubSubType::OutThirdRequestPubSubType()
    {
        setName("RBIC1::OutThirdRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutThirdRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutThirdRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutThirdRequest_max_key_cdr_typesize > 16 ? RBIC1_OutThirdRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutThirdRequestPubSubType::~OutThirdRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutThirdRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutThirdRequest* p_type = static_cast<OutThirdRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutThirdRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutThirdRequest* p_type = static_cast<OutThirdRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutThirdRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutThirdRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutThirdRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutThirdRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutThirdRequest());
    }

    void OutThirdRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutThirdRequest*>(data));
    }

    bool OutThirdRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutThirdRequest* p_type = static_cast<OutThirdRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutThirdRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutThirdRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutThirdReplyPubSubType::OutThirdReplyPubSubType()
    {
        setName("RBIC1::OutThirdReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutThirdReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutThirdReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutThirdReply_max_key_cdr_typesize > 16 ? RBIC1_OutThirdReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutThirdReplyPubSubType::~OutThirdReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutThirdReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutThirdReply* p_type = static_cast<OutThirdReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutThirdReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutThirdReply* p_type = static_cast<OutThirdReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutThirdReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutThirdReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutThirdReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutThirdReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutThirdReply());
    }

    void OutThirdReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutThirdReply*>(data));
    }

    bool OutThirdReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutThirdReply* p_type = static_cast<OutThirdReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutThirdReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutThirdReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    TQuadRequestPubSubType::TQuadRequestPubSubType()
    {
        setName("RBIC1::TQuadRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(TQuadRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_TQuadRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_TQuadRequest_max_key_cdr_typesize > 16 ? RBIC1_TQuadRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    TQuadRequestPubSubType::~TQuadRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool TQuadRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        TQuadRequest* p_type = static_cast<TQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool TQuadRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            TQuadRequest* p_type = static_cast<TQuadRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TQuadRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TQuadRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<TQuadRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* TQuadRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new TQuadRequest());
    }

    void TQuadRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<TQuadRequest*>(data));
    }

    bool TQuadRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        TQuadRequest* p_type = static_cast<TQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_TQuadRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_TQuadRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    TQuadReplyPubSubType::TQuadReplyPubSubType()
    {
        setName("RBIC1::TQuadReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(TQuadReply::getMaxCdrSerializedSize());
    #else
            RBIC1_TQuadReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_TQuadReply_max_key_cdr_typesize > 16 ? RBIC1_TQuadReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    TQuadReplyPubSubType::~TQuadReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool TQuadReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        TQuadReply* p_type = static_cast<TQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool TQuadReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            TQuadReply* p_type = static_cast<TQuadReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> TQuadReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<TQuadReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<TQuadReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* TQuadReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new TQuadReply());
    }

    void TQuadReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<TQuadReply*>(data));
    }

    bool TQuadReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        TQuadReply* p_type = static_cast<TQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_TQuadReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_TQuadReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutLinTLinRequestPubSubType::OutLinTLinRequestPubSubType()
    {
        setName("RBIC1::OutLinTLinRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinTLinRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinTLinRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinTLinRequest_max_key_cdr_typesize > 16 ? RBIC1_OutLinTLinRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinTLinRequestPubSubType::~OutLinTLinRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinTLinRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinTLinRequest* p_type = static_cast<OutLinTLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinTLinRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinTLinRequest* p_type = static_cast<OutLinTLinRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinTLinRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinTLinRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinTLinRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinTLinRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinTLinRequest());
    }

    void OutLinTLinRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinTLinRequest*>(data));
    }

    bool OutLinTLinRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinTLinRequest* p_type = static_cast<OutLinTLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinTLinRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinTLinRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutLinTLinReplyPubSubType::OutLinTLinReplyPubSubType()
    {
        setName("RBIC1::OutLinTLinReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinTLinReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinTLinReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinTLinReply_max_key_cdr_typesize > 16 ? RBIC1_OutLinTLinReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinTLinReplyPubSubType::~OutLinTLinReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinTLinReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinTLinReply* p_type = static_cast<OutLinTLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinTLinReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinTLinReply* p_type = static_cast<OutLinTLinReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinTLinReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinTLinReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinTLinReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinTLinReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinTLinReply());
    }

    void OutLinTLinReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinTLinReply*>(data));
    }

    bool OutLinTLinReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinTLinReply* p_type = static_cast<OutLinTLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinTLinReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinTLinReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadTLinRequestPubSubType::OutQuadTLinRequestPubSubType()
    {
        setName("RBIC1::OutQuadTLinRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadTLinRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadTLinRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadTLinRequest_max_key_cdr_typesize > 16 ? RBIC1_OutQuadTLinRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadTLinRequestPubSubType::~OutQuadTLinRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadTLinRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadTLinRequest* p_type = static_cast<OutQuadTLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadTLinRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadTLinRequest* p_type = static_cast<OutQuadTLinRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadTLinRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadTLinRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadTLinRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadTLinRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadTLinRequest());
    }

    void OutQuadTLinRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadTLinRequest*>(data));
    }

    bool OutQuadTLinRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadTLinRequest* p_type = static_cast<OutQuadTLinRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadTLinRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadTLinRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadTLinReplyPubSubType::OutQuadTLinReplyPubSubType()
    {
        setName("RBIC1::OutQuadTLinReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadTLinReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadTLinReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadTLinReply_max_key_cdr_typesize > 16 ? RBIC1_OutQuadTLinReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadTLinReplyPubSubType::~OutQuadTLinReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadTLinReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadTLinReply* p_type = static_cast<OutQuadTLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadTLinReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadTLinReply* p_type = static_cast<OutQuadTLinReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadTLinReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadTLinReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadTLinReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadTLinReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadTLinReply());
    }

    void OutQuadTLinReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadTLinReply*>(data));
    }

    bool OutQuadTLinReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadTLinReply* p_type = static_cast<OutQuadTLinReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadTLinReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadTLinReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutLinTQuadRequestPubSubType::OutLinTQuadRequestPubSubType()
    {
        setName("RBIC1::OutLinTQuadRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinTQuadRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinTQuadRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinTQuadRequest_max_key_cdr_typesize > 16 ? RBIC1_OutLinTQuadRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinTQuadRequestPubSubType::~OutLinTQuadRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinTQuadRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinTQuadRequest* p_type = static_cast<OutLinTQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinTQuadRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinTQuadRequest* p_type = static_cast<OutLinTQuadRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinTQuadRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinTQuadRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinTQuadRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinTQuadRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinTQuadRequest());
    }

    void OutLinTQuadRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinTQuadRequest*>(data));
    }

    bool OutLinTQuadRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinTQuadRequest* p_type = static_cast<OutLinTQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinTQuadRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinTQuadRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutLinTQuadReplyPubSubType::OutLinTQuadReplyPubSubType()
    {
        setName("RBIC1::OutLinTQuadReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutLinTQuadReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutLinTQuadReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutLinTQuadReply_max_key_cdr_typesize > 16 ? RBIC1_OutLinTQuadReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutLinTQuadReplyPubSubType::~OutLinTQuadReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutLinTQuadReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutLinTQuadReply* p_type = static_cast<OutLinTQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutLinTQuadReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutLinTQuadReply* p_type = static_cast<OutLinTQuadReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutLinTQuadReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutLinTQuadReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutLinTQuadReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutLinTQuadReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutLinTQuadReply());
    }

    void OutLinTQuadReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutLinTQuadReply*>(data));
    }

    bool OutLinTQuadReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutLinTQuadReply* p_type = static_cast<OutLinTQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutLinTQuadReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutLinTQuadReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadTQuadRequestPubSubType::OutQuadTQuadRequestPubSubType()
    {
        setName("RBIC1::OutQuadTQuadRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadTQuadRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadTQuadRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadTQuadRequest_max_key_cdr_typesize > 16 ? RBIC1_OutQuadTQuadRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadTQuadRequestPubSubType::~OutQuadTQuadRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadTQuadRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadTQuadRequest* p_type = static_cast<OutQuadTQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadTQuadRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadTQuadRequest* p_type = static_cast<OutQuadTQuadRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadTQuadRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadTQuadRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadTQuadRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadTQuadRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadTQuadRequest());
    }

    void OutQuadTQuadRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadTQuadRequest*>(data));
    }

    bool OutQuadTQuadRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadTQuadRequest* p_type = static_cast<OutQuadTQuadRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadTQuadRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadTQuadRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    OutQuadTQuadReplyPubSubType::OutQuadTQuadReplyPubSubType()
    {
        setName("RBIC1::OutQuadTQuadReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(OutQuadTQuadReply::getMaxCdrSerializedSize());
    #else
            RBIC1_OutQuadTQuadReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_OutQuadTQuadReply_max_key_cdr_typesize > 16 ? RBIC1_OutQuadTQuadReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    OutQuadTQuadReplyPubSubType::~OutQuadTQuadReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool OutQuadTQuadReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        OutQuadTQuadReply* p_type = static_cast<OutQuadTQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool OutQuadTQuadReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            OutQuadTQuadReply* p_type = static_cast<OutQuadTQuadReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> OutQuadTQuadReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<OutQuadTQuadReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<OutQuadTQuadReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* OutQuadTQuadReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new OutQuadTQuadReply());
    }

    void OutQuadTQuadReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<OutQuadTQuadReply*>(data));
    }

    bool OutQuadTQuadReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        OutQuadTQuadReply* p_type = static_cast<OutQuadTQuadReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_OutQuadTQuadReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_OutQuadTQuadReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    ZMD31050Cal1RequestPubSubType::ZMD31050Cal1RequestPubSubType()
    {
        setName("RBIC1::ZMD31050Cal1Request");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(ZMD31050Cal1Request::getMaxCdrSerializedSize());
    #else
            RBIC1_ZMD31050Cal1Request_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_ZMD31050Cal1Request_max_key_cdr_typesize > 16 ? RBIC1_ZMD31050Cal1Request_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    ZMD31050Cal1RequestPubSubType::~ZMD31050Cal1RequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool ZMD31050Cal1RequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        ZMD31050Cal1Request* p_type = static_cast<ZMD31050Cal1Request*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool ZMD31050Cal1RequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            ZMD31050Cal1Request* p_type = static_cast<ZMD31050Cal1Request*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ZMD31050Cal1RequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ZMD31050Cal1Request*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<ZMD31050Cal1Request*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* ZMD31050Cal1RequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new ZMD31050Cal1Request());
    }

    void ZMD31050Cal1RequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<ZMD31050Cal1Request*>(data));
    }

    bool ZMD31050Cal1RequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        ZMD31050Cal1Request* p_type = static_cast<ZMD31050Cal1Request*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_ZMD31050Cal1Request_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_ZMD31050Cal1Request_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    ZMD31050Cal1ReplyPubSubType::ZMD31050Cal1ReplyPubSubType()
    {
        setName("RBIC1::ZMD31050Cal1Reply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(ZMD31050Cal1Reply::getMaxCdrSerializedSize());
    #else
            RBIC1_ZMD31050Cal1Reply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_ZMD31050Cal1Reply_max_key_cdr_typesize > 16 ? RBIC1_ZMD31050Cal1Reply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    ZMD31050Cal1ReplyPubSubType::~ZMD31050Cal1ReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool ZMD31050Cal1ReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        ZMD31050Cal1Reply* p_type = static_cast<ZMD31050Cal1Reply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool ZMD31050Cal1ReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            ZMD31050Cal1Reply* p_type = static_cast<ZMD31050Cal1Reply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ZMD31050Cal1ReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ZMD31050Cal1Reply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<ZMD31050Cal1Reply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* ZMD31050Cal1ReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new ZMD31050Cal1Reply());
    }

    void ZMD31050Cal1ReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<ZMD31050Cal1Reply*>(data));
    }

    bool ZMD31050Cal1ReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        ZMD31050Cal1Reply* p_type = static_cast<ZMD31050Cal1Reply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_ZMD31050Cal1Reply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_ZMD31050Cal1Reply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    ZMD31050Sim1RequestPubSubType::ZMD31050Sim1RequestPubSubType()
    {
        setName("RBIC1::ZMD31050Sim1Request");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(ZMD31050Sim1Request::getMaxCdrSerializedSize());
    #else
            RBIC1_ZMD31050Sim1Request_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_ZMD31050Sim1Request_max_key_cdr_typesize > 16 ? RBIC1_ZMD31050Sim1Request_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    ZMD31050Sim1RequestPubSubType::~ZMD31050Sim1RequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool ZMD31050Sim1RequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        ZMD31050Sim1Request* p_type = static_cast<ZMD31050Sim1Request*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool ZMD31050Sim1RequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            ZMD31050Sim1Request* p_type = static_cast<ZMD31050Sim1Request*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ZMD31050Sim1RequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ZMD31050Sim1Request*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<ZMD31050Sim1Request*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* ZMD31050Sim1RequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new ZMD31050Sim1Request());
    }

    void ZMD31050Sim1RequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<ZMD31050Sim1Request*>(data));
    }

    bool ZMD31050Sim1RequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        ZMD31050Sim1Request* p_type = static_cast<ZMD31050Sim1Request*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_ZMD31050Sim1Request_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_ZMD31050Sim1Request_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    ZMD31050Sim1ReplyPubSubType::ZMD31050Sim1ReplyPubSubType()
    {
        setName("RBIC1::ZMD31050Sim1Reply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(ZMD31050Sim1Reply::getMaxCdrSerializedSize());
    #else
            RBIC1_ZMD31050Sim1Reply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_ZMD31050Sim1Reply_max_key_cdr_typesize > 16 ? RBIC1_ZMD31050Sim1Reply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    ZMD31050Sim1ReplyPubSubType::~ZMD31050Sim1ReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool ZMD31050Sim1ReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        ZMD31050Sim1Reply* p_type = static_cast<ZMD31050Sim1Reply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool ZMD31050Sim1ReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            ZMD31050Sim1Reply* p_type = static_cast<ZMD31050Sim1Reply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> ZMD31050Sim1ReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<ZMD31050Sim1Reply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<ZMD31050Sim1Reply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* ZMD31050Sim1ReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new ZMD31050Sim1Reply());
    }

    void ZMD31050Sim1ReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<ZMD31050Sim1Reply*>(data));
    }

    bool ZMD31050Sim1ReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        ZMD31050Sim1Reply* p_type = static_cast<ZMD31050Sim1Reply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_ZMD31050Sim1Reply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_ZMD31050Sim1Reply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    DLLVersionRequestPubSubType::DLLVersionRequestPubSubType()
    {
        setName("RBIC1::DLLVersionRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(DLLVersionRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_DLLVersionRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_DLLVersionRequest_max_key_cdr_typesize > 16 ? RBIC1_DLLVersionRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    DLLVersionRequestPubSubType::~DLLVersionRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool DLLVersionRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        DLLVersionRequest* p_type = static_cast<DLLVersionRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool DLLVersionRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            DLLVersionRequest* p_type = static_cast<DLLVersionRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> DLLVersionRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<DLLVersionRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<DLLVersionRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* DLLVersionRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new DLLVersionRequest());
    }

    void DLLVersionRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<DLLVersionRequest*>(data));
    }

    bool DLLVersionRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        DLLVersionRequest* p_type = static_cast<DLLVersionRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_DLLVersionRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_DLLVersionRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    DLLVersionReplyPubSubType::DLLVersionReplyPubSubType()
    {
        setName("RBIC1::DLLVersionReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(DLLVersionReply::getMaxCdrSerializedSize());
    #else
            RBIC1_DLLVersionReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_DLLVersionReply_max_key_cdr_typesize > 16 ? RBIC1_DLLVersionReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    DLLVersionReplyPubSubType::~DLLVersionReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool DLLVersionReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        DLLVersionReply* p_type = static_cast<DLLVersionReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool DLLVersionReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            DLLVersionReply* p_type = static_cast<DLLVersionReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> DLLVersionReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<DLLVersionReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<DLLVersionReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* DLLVersionReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new DLLVersionReply());
    }

    void DLLVersionReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<DLLVersionReply*>(data));
    }

    bool DLLVersionReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        DLLVersionReply* p_type = static_cast<DLLVersionReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_DLLVersionReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_DLLVersionReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    GetMessageRequestPubSubType::GetMessageRequestPubSubType()
    {
        setName("RBIC1::GetMessageRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(GetMessageRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_GetMessageRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_GetMessageRequest_max_key_cdr_typesize > 16 ? RBIC1_GetMessageRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    GetMessageRequestPubSubType::~GetMessageRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool GetMessageRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        GetMessageRequest* p_type = static_cast<GetMessageRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool GetMessageRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            GetMessageRequest* p_type = static_cast<GetMessageRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GetMessageRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GetMessageRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<GetMessageRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* GetMessageRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new GetMessageRequest());
    }

    void GetMessageRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<GetMessageRequest*>(data));
    }

    bool GetMessageRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        GetMessageRequest* p_type = static_cast<GetMessageRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_GetMessageRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_GetMessageRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    GetMessageReplyPubSubType::GetMessageReplyPubSubType()
    {
        setName("RBIC1::GetMessageReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(GetMessageReply::getMaxCdrSerializedSize());
    #else
            RBIC1_GetMessageReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_GetMessageReply_max_key_cdr_typesize > 16 ? RBIC1_GetMessageReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    GetMessageReplyPubSubType::~GetMessageReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool GetMessageReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        GetMessageReply* p_type = static_cast<GetMessageReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool GetMessageReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            GetMessageReply* p_type = static_cast<GetMessageReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GetMessageReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GetMessageReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<GetMessageReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* GetMessageReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new GetMessageReply());
    }

    void GetMessageReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<GetMessageReply*>(data));
    }

    bool GetMessageReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        GetMessageReply* p_type = static_cast<GetMessageReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_GetMessageReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_GetMessageReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }











    GenericRequestPubSubType::GenericRequestPubSubType()
    {
        setName("RBIC1::GenericRequest");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(GenericRequest::getMaxCdrSerializedSize());
    #else
            RBIC1_GenericRequest_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_GenericRequest_max_key_cdr_typesize > 16 ? RBIC1_GenericRequest_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    GenericRequestPubSubType::~GenericRequestPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool GenericRequestPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        GenericRequest* p_type = static_cast<GenericRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool GenericRequestPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            GenericRequest* p_type = static_cast<GenericRequest*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GenericRequestPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GenericRequest*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<GenericRequest*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* GenericRequestPubSubType::createData()
    {
        return reinterpret_cast<void*>(new GenericRequest());
    }

    void GenericRequestPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<GenericRequest*>(data));
    }

    bool GenericRequestPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        GenericRequest* p_type = static_cast<GenericRequest*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_GenericRequest_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_GenericRequest_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }



    GenericReplyPubSubType::GenericReplyPubSubType()
    {
        setName("RBIC1::GenericReply");
        uint32_t type_size =
    #if FASTCDR_VERSION_MAJOR == 1
            static_cast<uint32_t>(GenericReply::getMaxCdrSerializedSize());
    #else
            RBIC1_GenericReply_max_cdr_typesize;
    #endif
        type_size += static_cast<uint32_t>(eprosima::fastcdr::Cdr::alignment(type_size, 4)); /* possible submessage alignment */
        m_typeSize = type_size + 4; /*encapsulation*/
        m_isGetKeyDefined = false;
        uint32_t keyLength = RBIC1_GenericReply_max_key_cdr_typesize > 16 ? RBIC1_GenericReply_max_key_cdr_typesize : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    GenericReplyPubSubType::~GenericReplyPubSubType()
    {
        if (m_keyBuffer != nullptr)
        {
            free(m_keyBuffer);
        }
    }

    bool GenericReplyPubSubType::serialize(
            void* data,
            SerializedPayload_t* payload,
            DataRepresentationId_t data_representation)
    {
        GenericReply* p_type = static_cast<GenericReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size);
        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                eprosima::fastcdr::CdrVersion::XCDRv1 : eprosima::fastcdr::CdrVersion::XCDRv2);
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    #if FASTCDR_VERSION_MAJOR > 1
        ser.set_encoding_flag(
            data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR  :
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2);
    #endif // FASTCDR_VERSION_MAJOR > 1

        try
        {
            // Serialize encapsulation
            ser.serialize_encapsulation();
            // Serialize the object.
            ser << *p_type;
    #if FASTCDR_VERSION_MAJOR > 1
            ser.set_dds_cdr_options({0,0});
    #else
            ser.setDDSCdrOptions(0);
    #endif // FASTCDR_VERSION_MAJOR > 1
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        // Get the serialized length
    #if FASTCDR_VERSION_MAJOR == 1
        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength());
    #else
        payload->length = static_cast<uint32_t>(ser.get_serialized_data_length());
    #endif // FASTCDR_VERSION_MAJOR == 1
        return true;
    }

    bool GenericReplyPubSubType::deserialize(
            SerializedPayload_t* payload,
            void* data)
    {
        try
        {
            // Convert DATA to pointer of your type
            GenericReply* p_type = static_cast<GenericReply*>(data);

            // Object that manages the raw buffer.
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length);

            // Object that deserializes the data.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN
    #if FASTCDR_VERSION_MAJOR == 1
                    , eprosima::fastcdr::Cdr::CdrType::DDS_CDR
    #endif // FASTCDR_VERSION_MAJOR == 1
                    );

            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            // Deserialize the object.
            deser >> *p_type;
        }
        catch (eprosima::fastcdr::exception::Exception& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> GenericReplyPubSubType::getSerializedSizeProvider(
            void* data,
            DataRepresentationId_t data_representation)
    {
        return [data, data_representation]() -> uint32_t
               {
    #if FASTCDR_VERSION_MAJOR == 1
                   static_cast<void>(data_representation);
                   return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<GenericReply*>(data))) +
                          4u /*encapsulation*/;
    #else
                   try
                   {
                       eprosima::fastcdr::CdrSizeCalculator calculator(
                           data_representation == DataRepresentationId_t::XCDR_DATA_REPRESENTATION ?
                           eprosima::fastcdr::CdrVersion::XCDRv1 :eprosima::fastcdr::CdrVersion::XCDRv2);
                       size_t current_alignment {0};
                       return static_cast<uint32_t>(calculator.calculate_serialized_size(
                                   *static_cast<GenericReply*>(data), current_alignment)) +
                               4u /*encapsulation*/;
                   }
                   catch (eprosima::fastcdr::exception::Exception& /*exception*/)
                   {
                       return 0;
                   }
    #endif // FASTCDR_VERSION_MAJOR == 1
               };
    }

    void* GenericReplyPubSubType::createData()
    {
        return reinterpret_cast<void*>(new GenericReply());
    }

    void GenericReplyPubSubType::deleteData(
            void* data)
    {
        delete(reinterpret_cast<GenericReply*>(data));
    }

    bool GenericReplyPubSubType::getKey(
            void* data,
            InstanceHandle_t* handle,
            bool force_md5)
    {
        if (!m_isGetKeyDefined)
        {
            return false;
        }

        GenericReply* p_type = static_cast<GenericReply*>(data);

        // Object that manages the raw buffer.
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),
                RBIC1_GenericReply_max_key_cdr_typesize);

        // Object that serializes the data.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS, eprosima::fastcdr::CdrVersion::XCDRv1);
    #if FASTCDR_VERSION_MAJOR == 1
        p_type->serializeKey(ser);
    #else
        eprosima::fastcdr::serialize_key(ser, *p_type);
    #endif // FASTCDR_VERSION_MAJOR == 1
        if (force_md5 || RBIC1_GenericReply_max_key_cdr_typesize > 16)
        {
            m_md5.init();
    #if FASTCDR_VERSION_MAJOR == 1
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
    #else
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.get_serialized_data_length()));
    #endif // FASTCDR_VERSION_MAJOR == 1
            m_md5.finalize();
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else
        {
            for (uint8_t i = 0; i < 16; ++i)
            {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }


} //End of namespace RBIC1

