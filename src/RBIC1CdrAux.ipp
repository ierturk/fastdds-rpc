// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file RBIC1CdrAux.ipp
 * This source file contains some declarations of CDR related functions.
 *
 * This file was generated by the tool fastddsgen.
 */

#ifndef _FAST_DDS_GENERATED_RBIC1_RBIC1CDRAUX_IPP_
#define _FAST_DDS_GENERATED_RBIC1_RBIC1CDRAUX_IPP_

#include "RBIC1CdrAux.hpp"

#include <fastcdr/Cdr.h>
#include <fastcdr/CdrSizeCalculator.hpp>


#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

namespace eprosima {
namespace fastcdr {



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.b(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.a()
        << eprosima::fastcdr::MemberId(3) << data.b()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.a();
                                            break;

                                        case 3:
                                                dcdr >> data.b();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::TLinRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.tMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.tUpp(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TLinRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.ztMed()
        << eprosima::fastcdr::MemberId(1) << data.ztUpp()
        << eprosima::fastcdr::MemberId(2) << data.tMed()
        << eprosima::fastcdr::MemberId(3) << data.tUpp()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::TLinRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 1:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 2:
                                                dcdr >> data.tMed();
                                            break;

                                        case 3:
                                                dcdr >> data.tUpp();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TLinRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::TLinReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ct0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ct1(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TLinReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.ct0()
        << eprosima::fastcdr::MemberId(2) << data.ct1()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::TLinReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.ct0();
                                            break;

                                        case 2:
                                                dcdr >> data.ct1();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TLinReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp3m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp3m()
        << eprosima::fastcdr::MemberId(3) << data.a()
        << eprosima::fastcdr::MemberId(4) << data.b()
        << eprosima::fastcdr::MemberId(5) << data.m()
        << eprosima::fastcdr::MemberId(6) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp3m();
                                            break;

                                        case 3:
                                                dcdr >> data.a();
                                            break;

                                        case 4:
                                                dcdr >> data.b();
                                            break;

                                        case 5:
                                                dcdr >> data.m();
                                            break;

                                        case 6:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c2(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c2()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c2();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutThirdRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp3m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp4m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.m2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutThirdRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp3m()
        << eprosima::fastcdr::MemberId(3) << data.zp4m()
        << eprosima::fastcdr::MemberId(4) << data.a()
        << eprosima::fastcdr::MemberId(5) << data.b()
        << eprosima::fastcdr::MemberId(6) << data.m()
        << eprosima::fastcdr::MemberId(7) << data.m2()
        << eprosima::fastcdr::MemberId(8) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutThirdRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp3m();
                                            break;

                                        case 3:
                                                dcdr >> data.zp4m();
                                            break;

                                        case 4:
                                                dcdr >> data.a();
                                            break;

                                        case 5:
                                                dcdr >> data.b();
                                            break;

                                        case 6:
                                                dcdr >> data.m();
                                            break;

                                        case 7:
                                                dcdr >> data.m2();
                                            break;

                                        case 8:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutThirdRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutThirdReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c3(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutThirdReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c2()
        << eprosima::fastcdr::MemberId(4) << data.c3()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutThirdReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c2();
                                            break;

                                        case 4:
                                                dcdr >> data.c3();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutThirdReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::TQuadRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.ztLow(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.tLow(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.tUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.tMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TQuadRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.ztLow()
        << eprosima::fastcdr::MemberId(1) << data.ztUpp()
        << eprosima::fastcdr::MemberId(2) << data.ztMed()
        << eprosima::fastcdr::MemberId(3) << data.tLow()
        << eprosima::fastcdr::MemberId(4) << data.tUpp()
        << eprosima::fastcdr::MemberId(5) << data.tMed()
        << eprosima::fastcdr::MemberId(6) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::TQuadRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.ztLow();
                                            break;

                                        case 1:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 2:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 3:
                                                dcdr >> data.tLow();
                                            break;

                                        case 4:
                                                dcdr >> data.tUpp();
                                            break;

                                        case 5:
                                                dcdr >> data.tMed();
                                            break;

                                        case 6:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TQuadRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::TQuadReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.ct0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.ct1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.ct2(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TQuadReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.ct0()
        << eprosima::fastcdr::MemberId(2) << data.ct1()
        << eprosima::fastcdr::MemberId(3) << data.ct2()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::TQuadReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.ct0();
                                            break;

                                        case 2:
                                                dcdr >> data.ct1();
                                            break;

                                        case 3:
                                                dcdr >> data.ct2();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::TQuadReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinTLinRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp1u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp2u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTLinRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp1u()
        << eprosima::fastcdr::MemberId(3) << data.zp2u()
        << eprosima::fastcdr::MemberId(4) << data.a()
        << eprosima::fastcdr::MemberId(5) << data.b()
        << eprosima::fastcdr::MemberId(6) << data.ztMed()
        << eprosima::fastcdr::MemberId(7) << data.ztUpp()
        << eprosima::fastcdr::MemberId(8) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinTLinRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp1u();
                                            break;

                                        case 3:
                                                dcdr >> data.zp2u();
                                            break;

                                        case 4:
                                                dcdr >> data.a();
                                            break;

                                        case 5:
                                                dcdr >> data.b();
                                            break;

                                        case 6:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 7:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 8:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTLinRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinTLinReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c6(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTLinReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c4()
        << eprosima::fastcdr::MemberId(4) << data.c6()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinTLinReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c4();
                                            break;

                                        case 4:
                                                dcdr >> data.c6();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTLinReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadTLinRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp3m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp1u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.zp2u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTLinRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp3m()
        << eprosima::fastcdr::MemberId(3) << data.zp1u()
        << eprosima::fastcdr::MemberId(4) << data.zp2u()
        << eprosima::fastcdr::MemberId(5) << data.a()
        << eprosima::fastcdr::MemberId(6) << data.b()
        << eprosima::fastcdr::MemberId(7) << data.m()
        << eprosima::fastcdr::MemberId(8) << data.ztMed()
        << eprosima::fastcdr::MemberId(9) << data.ztUpp()
        << eprosima::fastcdr::MemberId(10) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadTLinRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp3m();
                                            break;

                                        case 3:
                                                dcdr >> data.zp1u();
                                            break;

                                        case 4:
                                                dcdr >> data.zp2u();
                                            break;

                                        case 5:
                                                dcdr >> data.a();
                                            break;

                                        case 6:
                                                dcdr >> data.b();
                                            break;

                                        case 7:
                                                dcdr >> data.m();
                                            break;

                                        case 8:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 9:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 10:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTLinRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadTLinReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.c6(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTLinReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c2()
        << eprosima::fastcdr::MemberId(4) << data.c4()
        << eprosima::fastcdr::MemberId(5) << data.c6()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadTLinReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c2();
                                            break;

                                        case 4:
                                                dcdr >> data.c4();
                                            break;

                                        case 5:
                                                dcdr >> data.c6();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTLinReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinTQuadRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp1u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp2u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.zp1l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.zp2l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.ztLow(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTQuadRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp1u()
        << eprosima::fastcdr::MemberId(3) << data.zp2u()
        << eprosima::fastcdr::MemberId(4) << data.zp1l()
        << eprosima::fastcdr::MemberId(5) << data.zp2l()
        << eprosima::fastcdr::MemberId(6) << data.a()
        << eprosima::fastcdr::MemberId(7) << data.b()
        << eprosima::fastcdr::MemberId(8) << data.ztMed()
        << eprosima::fastcdr::MemberId(9) << data.ztUpp()
        << eprosima::fastcdr::MemberId(10) << data.ztLow()
        << eprosima::fastcdr::MemberId(11) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinTQuadRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp1u();
                                            break;

                                        case 3:
                                                dcdr >> data.zp2u();
                                            break;

                                        case 4:
                                                dcdr >> data.zp1l();
                                            break;

                                        case 5:
                                                dcdr >> data.zp2l();
                                            break;

                                        case 6:
                                                dcdr >> data.a();
                                            break;

                                        case 7:
                                                dcdr >> data.b();
                                            break;

                                        case 8:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 9:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 10:
                                                dcdr >> data.ztLow();
                                            break;

                                        case 11:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTQuadRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutLinTQuadReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c6(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.c5(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.c7(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTQuadReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c4()
        << eprosima::fastcdr::MemberId(4) << data.c6()
        << eprosima::fastcdr::MemberId(5) << data.c5()
        << eprosima::fastcdr::MemberId(6) << data.c7()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutLinTQuadReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c4();
                                            break;

                                        case 4:
                                                dcdr >> data.c6();
                                            break;

                                        case 5:
                                                dcdr >> data.c5();
                                            break;

                                        case 6:
                                                dcdr >> data.c7();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutLinTQuadReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadTQuadRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp3m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp1u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.zp2u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.zp1l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.zp2l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                data.ztLow(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTQuadRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp3m()
        << eprosima::fastcdr::MemberId(3) << data.zp1u()
        << eprosima::fastcdr::MemberId(4) << data.zp2u()
        << eprosima::fastcdr::MemberId(5) << data.zp1l()
        << eprosima::fastcdr::MemberId(6) << data.zp2l()
        << eprosima::fastcdr::MemberId(7) << data.a()
        << eprosima::fastcdr::MemberId(8) << data.b()
        << eprosima::fastcdr::MemberId(9) << data.m()
        << eprosima::fastcdr::MemberId(10) << data.ztMed()
        << eprosima::fastcdr::MemberId(11) << data.ztUpp()
        << eprosima::fastcdr::MemberId(12) << data.ztLow()
        << eprosima::fastcdr::MemberId(13) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadTQuadRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp3m();
                                            break;

                                        case 3:
                                                dcdr >> data.zp1u();
                                            break;

                                        case 4:
                                                dcdr >> data.zp2u();
                                            break;

                                        case 5:
                                                dcdr >> data.zp1l();
                                            break;

                                        case 6:
                                                dcdr >> data.zp2l();
                                            break;

                                        case 7:
                                                dcdr >> data.a();
                                            break;

                                        case 8:
                                                dcdr >> data.b();
                                            break;

                                        case 9:
                                                dcdr >> data.m();
                                            break;

                                        case 10:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 11:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 12:
                                                dcdr >> data.ztLow();
                                            break;

                                        case 13:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTQuadRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::OutQuadTQuadReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.c6(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.c5(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.c7(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTQuadReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c2()
        << eprosima::fastcdr::MemberId(4) << data.c4()
        << eprosima::fastcdr::MemberId(5) << data.c6()
        << eprosima::fastcdr::MemberId(6) << data.c5()
        << eprosima::fastcdr::MemberId(7) << data.c7()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::OutQuadTQuadReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c2();
                                            break;

                                        case 4:
                                                dcdr >> data.c4();
                                            break;

                                        case 5:
                                                dcdr >> data.c6();
                                            break;

                                        case 6:
                                                dcdr >> data.c5();
                                            break;

                                        case 7:
                                                dcdr >> data.c7();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::OutQuadTQuadReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::ZMD31050Cal1Request& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.zp1m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.zp2m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.zp3m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.zp4m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.zp1u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.zp2u(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.zp1l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.zp2l(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.a(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.b(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.m(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                data.m2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                data.ztMed(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                data.ztUpp(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(14),
                data.ztLow(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(15),
                data.adcReso(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Cal1Request& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.zp1m()
        << eprosima::fastcdr::MemberId(1) << data.zp2m()
        << eprosima::fastcdr::MemberId(2) << data.zp3m()
        << eprosima::fastcdr::MemberId(3) << data.zp4m()
        << eprosima::fastcdr::MemberId(4) << data.zp1u()
        << eprosima::fastcdr::MemberId(5) << data.zp2u()
        << eprosima::fastcdr::MemberId(6) << data.zp1l()
        << eprosima::fastcdr::MemberId(7) << data.zp2l()
        << eprosima::fastcdr::MemberId(8) << data.a()
        << eprosima::fastcdr::MemberId(9) << data.b()
        << eprosima::fastcdr::MemberId(10) << data.m()
        << eprosima::fastcdr::MemberId(11) << data.m2()
        << eprosima::fastcdr::MemberId(12) << data.ztMed()
        << eprosima::fastcdr::MemberId(13) << data.ztUpp()
        << eprosima::fastcdr::MemberId(14) << data.ztLow()
        << eprosima::fastcdr::MemberId(15) << data.adcReso()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::ZMD31050Cal1Request& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.zp1m();
                                            break;

                                        case 1:
                                                dcdr >> data.zp2m();
                                            break;

                                        case 2:
                                                dcdr >> data.zp3m();
                                            break;

                                        case 3:
                                                dcdr >> data.zp4m();
                                            break;

                                        case 4:
                                                dcdr >> data.zp1u();
                                            break;

                                        case 5:
                                                dcdr >> data.zp2u();
                                            break;

                                        case 6:
                                                dcdr >> data.zp1l();
                                            break;

                                        case 7:
                                                dcdr >> data.zp2l();
                                            break;

                                        case 8:
                                                dcdr >> data.a();
                                            break;

                                        case 9:
                                                dcdr >> data.b();
                                            break;

                                        case 10:
                                                dcdr >> data.m();
                                            break;

                                        case 11:
                                                dcdr >> data.m2();
                                            break;

                                        case 12:
                                                dcdr >> data.ztMed();
                                            break;

                                        case 13:
                                                dcdr >> data.ztUpp();
                                            break;

                                        case 14:
                                                dcdr >> data.ztLow();
                                            break;

                                        case 15:
                                                dcdr >> data.adcReso();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Cal1Request& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::ZMD31050Cal1Reply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c3(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.c6(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.c5(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.c7(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Cal1Reply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.c0()
        << eprosima::fastcdr::MemberId(2) << data.c1()
        << eprosima::fastcdr::MemberId(3) << data.c2()
        << eprosima::fastcdr::MemberId(4) << data.c3()
        << eprosima::fastcdr::MemberId(5) << data.c4()
        << eprosima::fastcdr::MemberId(6) << data.c6()
        << eprosima::fastcdr::MemberId(7) << data.c5()
        << eprosima::fastcdr::MemberId(8) << data.c7()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::ZMD31050Cal1Reply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.c0();
                                            break;

                                        case 2:
                                                dcdr >> data.c1();
                                            break;

                                        case 3:
                                                dcdr >> data.c2();
                                            break;

                                        case 4:
                                                dcdr >> data.c3();
                                            break;

                                        case 5:
                                                dcdr >> data.c4();
                                            break;

                                        case 6:
                                                dcdr >> data.c6();
                                            break;

                                        case 7:
                                                dcdr >> data.c5();
                                            break;

                                        case 8:
                                                dcdr >> data.c7();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Cal1Reply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::ZMD31050Sim1Request& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.c0(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.c1(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                data.c2(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                data.c3(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                data.c4(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                data.c5(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                data.c6(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                data.c7(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                data.adcReso(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                data.rangeShift(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                data.izMin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                data.izMax(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                data.zt(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                data.ztMin(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(14),
                data.ztMax(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Sim1Request& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.c0()
        << eprosima::fastcdr::MemberId(1) << data.c1()
        << eprosima::fastcdr::MemberId(2) << data.c2()
        << eprosima::fastcdr::MemberId(3) << data.c3()
        << eprosima::fastcdr::MemberId(4) << data.c4()
        << eprosima::fastcdr::MemberId(5) << data.c5()
        << eprosima::fastcdr::MemberId(6) << data.c6()
        << eprosima::fastcdr::MemberId(7) << data.c7()
        << eprosima::fastcdr::MemberId(8) << data.adcReso()
        << eprosima::fastcdr::MemberId(9) << data.rangeShift()
        << eprosima::fastcdr::MemberId(10) << data.izMin()
        << eprosima::fastcdr::MemberId(11) << data.izMax()
        << eprosima::fastcdr::MemberId(12) << data.zt()
        << eprosima::fastcdr::MemberId(13) << data.ztMin()
        << eprosima::fastcdr::MemberId(14) << data.ztMax()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::ZMD31050Sim1Request& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.c0();
                                            break;

                                        case 1:
                                                dcdr >> data.c1();
                                            break;

                                        case 2:
                                                dcdr >> data.c2();
                                            break;

                                        case 3:
                                                dcdr >> data.c3();
                                            break;

                                        case 4:
                                                dcdr >> data.c4();
                                            break;

                                        case 5:
                                                dcdr >> data.c5();
                                            break;

                                        case 6:
                                                dcdr >> data.c6();
                                            break;

                                        case 7:
                                                dcdr >> data.c7();
                                            break;

                                        case 8:
                                                dcdr >> data.adcReso();
                                            break;

                                        case 9:
                                                dcdr >> data.rangeShift();
                                            break;

                                        case 10:
                                                dcdr >> data.izMin();
                                            break;

                                        case 11:
                                                dcdr >> data.izMax();
                                            break;

                                        case 12:
                                                dcdr >> data.zt();
                                            break;

                                        case 13:
                                                dcdr >> data.ztMin();
                                            break;

                                        case 14:
                                                dcdr >> data.ztMax();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Sim1Request& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::ZMD31050Sim1Reply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.result(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Sim1Reply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.result()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::ZMD31050Sim1Reply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.result();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ZMD31050Sim1Reply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::DLLVersionRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::DLLVersionRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::DLLVersionRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    static_cast<void>(dcdr);
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::DLLVersionRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::DLLVersionReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.success(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.version(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::DLLVersionReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.success()
        << eprosima::fastcdr::MemberId(1) << data.version()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::DLLVersionReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.success();
                                            break;

                                        case 1:
                                                dcdr >> data.version();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::DLLVersionReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}


template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::GetMessageRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};



    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GetMessageRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    static_cast<void>(data);

    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::GetMessageRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    static_cast<void>(dcdr);
                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GetMessageRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::GetMessageReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.message(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GetMessageReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.message()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::GetMessageReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.message();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GetMessageReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::RequestUnion& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
        case RBIC1::OUTLIN_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.outLinRequest(), current_alignment);
                    break;

        case RBIC1::TLIN_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.tLinRequest(), current_alignment);
                    break;

        case RBIC1::OUTQUAD_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.outQuadRequest(), current_alignment);
                    break;

        case RBIC1::OUTTHIRD_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.outThirdRequest(), current_alignment);
                    break;

        case RBIC1::TQUAD_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.tQuadRequest(), current_alignment);
                    break;

        case RBIC1::OUTLINTLIN_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.outLinTLinRequest(), current_alignment);
                    break;

        case RBIC1::OUTQUADTLIN_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.outQuadTLinRequest(), current_alignment);
                    break;

        case RBIC1::OUTLINTQUAD_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.outLinTQuadRequest(), current_alignment);
                    break;

        case RBIC1::OUTQUADTQUAD_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.outQuadTQuadRequest(), current_alignment);
                    break;

        case RBIC1::ZMD31050_CAL1_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.zmd31050Cal1Request(), current_alignment);
                    break;

        case RBIC1::ZMD31050_SIM1_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.zmd31050Sim1Request(), current_alignment);
                    break;

        case RBIC1::DLLVERSION_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                                data.dllVersionRequest(), current_alignment);
                    break;

        case RBIC1::GETMESSAGE_REQUEST:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                                data.getMessageRequest(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::RequestUnion& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case RBIC1::OUTLIN_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(1) << data.outLinRequest();
                    break;

                case RBIC1::TLIN_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(2) << data.tLinRequest();
                    break;

                case RBIC1::OUTQUAD_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(3) << data.outQuadRequest();
                    break;

                case RBIC1::OUTTHIRD_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(4) << data.outThirdRequest();
                    break;

                case RBIC1::TQUAD_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(5) << data.tQuadRequest();
                    break;

                case RBIC1::OUTLINTLIN_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(6) << data.outLinTLinRequest();
                    break;

                case RBIC1::OUTQUADTLIN_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(7) << data.outQuadTLinRequest();
                    break;

                case RBIC1::OUTLINTQUAD_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(8) << data.outLinTQuadRequest();
                    break;

                case RBIC1::OUTQUADTQUAD_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(9) << data.outQuadTQuadRequest();
                    break;

                case RBIC1::ZMD31050_CAL1_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(10) << data.zmd31050Cal1Request();
                    break;

                case RBIC1::ZMD31050_SIM1_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(11) << data.zmd31050Sim1Request();
                    break;

                case RBIC1::DLLVERSION_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(12) << data.dllVersionRequest();
                    break;

                case RBIC1::GETMESSAGE_REQUEST:
                    scdr << eprosima::fastcdr::MemberId(13) << data.getMessageRequest();
                    break;

        default:
            break;
    }

    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::RequestUnion& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> data._d();
                        break;
                    default:
                        switch (data._d())
                        {
                                                        case RBIC1::OUTLIN_REQUEST:
                                                            dcdr >> data.outLinRequest();
                                                            break;

                                                        case RBIC1::TLIN_REQUEST:
                                                            dcdr >> data.tLinRequest();
                                                            break;

                                                        case RBIC1::OUTQUAD_REQUEST:
                                                            dcdr >> data.outQuadRequest();
                                                            break;

                                                        case RBIC1::OUTTHIRD_REQUEST:
                                                            dcdr >> data.outThirdRequest();
                                                            break;

                                                        case RBIC1::TQUAD_REQUEST:
                                                            dcdr >> data.tQuadRequest();
                                                            break;

                                                        case RBIC1::OUTLINTLIN_REQUEST:
                                                            dcdr >> data.outLinTLinRequest();
                                                            break;

                                                        case RBIC1::OUTQUADTLIN_REQUEST:
                                                            dcdr >> data.outQuadTLinRequest();
                                                            break;

                                                        case RBIC1::OUTLINTQUAD_REQUEST:
                                                            dcdr >> data.outLinTQuadRequest();
                                                            break;

                                                        case RBIC1::OUTQUADTQUAD_REQUEST:
                                                            dcdr >> data.outQuadTQuadRequest();
                                                            break;

                                                        case RBIC1::ZMD31050_CAL1_REQUEST:
                                                            dcdr >> data.zmd31050Cal1Request();
                                                            break;

                                                        case RBIC1::ZMD31050_SIM1_REQUEST:
                                                            dcdr >> data.zmd31050Sim1Request();
                                                            break;

                                                        case RBIC1::DLLVERSION_REQUEST:
                                                            dcdr >> data.dllVersionRequest();
                                                            break;

                                                        case RBIC1::GETMESSAGE_REQUEST:
                                                            dcdr >> data.getMessageRequest();
                                                            break;

                            default:
                                break;
                        }
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::ReplyUnion& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};

    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0), data._d(),
                    current_alignment);

    switch (data._d())
    {
        case RBIC1::OUTLIN_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                                data.outLinReply(), current_alignment);
                    break;

        case RBIC1::TLIN_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(2),
                                data.tLinReply(), current_alignment);
                    break;

        case RBIC1::OUTQUAD_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(3),
                                data.outQuadReply(), current_alignment);
                    break;

        case RBIC1::OUTTHIRD_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(4),
                                data.outThirdReply(), current_alignment);
                    break;

        case RBIC1::TQUAD_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(5),
                                data.tQuadReply(), current_alignment);
                    break;

        case RBIC1::OUTLINTLIN_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(6),
                                data.outLinTLinReply(), current_alignment);
                    break;

        case RBIC1::OUTQUADTLIN_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(7),
                                data.outQuadTLinReply(), current_alignment);
                    break;

        case RBIC1::OUTLINTQUAD_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(8),
                                data.outLinTQuadReply(), current_alignment);
                    break;

        case RBIC1::OUTQUADTQUAD_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(9),
                                data.outQuadTQuadReply(), current_alignment);
                    break;

        case RBIC1::ZMD31050_CAL1_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(10),
                                data.zmd31050Cal1Reply(), current_alignment);
                    break;

        case RBIC1::ZMD31050_SIM1_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(11),
                                data.zmd31050Sim1Reply(), current_alignment);
                    break;

        case RBIC1::DLLVERSION_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(12),
                                data.dllVersionReply(), current_alignment);
                    break;

        case RBIC1::GETMESSAGE_REPLY:
                    calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(13),
                                data.getMessageReply(), current_alignment);
                    break;

        default:
            break;
    }

    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}


template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::ReplyUnion& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr << eprosima::fastcdr::MemberId(0) << data._d();

    switch (data._d())
    {
                case RBIC1::OUTLIN_REPLY:
                    scdr << eprosima::fastcdr::MemberId(1) << data.outLinReply();
                    break;

                case RBIC1::TLIN_REPLY:
                    scdr << eprosima::fastcdr::MemberId(2) << data.tLinReply();
                    break;

                case RBIC1::OUTQUAD_REPLY:
                    scdr << eprosima::fastcdr::MemberId(3) << data.outQuadReply();
                    break;

                case RBIC1::OUTTHIRD_REPLY:
                    scdr << eprosima::fastcdr::MemberId(4) << data.outThirdReply();
                    break;

                case RBIC1::TQUAD_REPLY:
                    scdr << eprosima::fastcdr::MemberId(5) << data.tQuadReply();
                    break;

                case RBIC1::OUTLINTLIN_REPLY:
                    scdr << eprosima::fastcdr::MemberId(6) << data.outLinTLinReply();
                    break;

                case RBIC1::OUTQUADTLIN_REPLY:
                    scdr << eprosima::fastcdr::MemberId(7) << data.outQuadTLinReply();
                    break;

                case RBIC1::OUTLINTQUAD_REPLY:
                    scdr << eprosima::fastcdr::MemberId(8) << data.outLinTQuadReply();
                    break;

                case RBIC1::OUTQUADTQUAD_REPLY:
                    scdr << eprosima::fastcdr::MemberId(9) << data.outQuadTQuadReply();
                    break;

                case RBIC1::ZMD31050_CAL1_REPLY:
                    scdr << eprosima::fastcdr::MemberId(10) << data.zmd31050Cal1Reply();
                    break;

                case RBIC1::ZMD31050_SIM1_REPLY:
                    scdr << eprosima::fastcdr::MemberId(11) << data.zmd31050Sim1Reply();
                    break;

                case RBIC1::DLLVERSION_REPLY:
                    scdr << eprosima::fastcdr::MemberId(12) << data.dllVersionReply();
                    break;

                case RBIC1::GETMESSAGE_REPLY:
                    scdr << eprosima::fastcdr::MemberId(13) << data.getMessageReply();
                    break;

        default:
            break;
    }

    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::ReplyUnion& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                    case 0:
                        dcdr >> data._d();
                        break;
                    default:
                        switch (data._d())
                        {
                                                        case RBIC1::OUTLIN_REPLY:
                                                            dcdr >> data.outLinReply();
                                                            break;

                                                        case RBIC1::TLIN_REPLY:
                                                            dcdr >> data.tLinReply();
                                                            break;

                                                        case RBIC1::OUTQUAD_REPLY:
                                                            dcdr >> data.outQuadReply();
                                                            break;

                                                        case RBIC1::OUTTHIRD_REPLY:
                                                            dcdr >> data.outThirdReply();
                                                            break;

                                                        case RBIC1::TQUAD_REPLY:
                                                            dcdr >> data.tQuadReply();
                                                            break;

                                                        case RBIC1::OUTLINTLIN_REPLY:
                                                            dcdr >> data.outLinTLinReply();
                                                            break;

                                                        case RBIC1::OUTQUADTLIN_REPLY:
                                                            dcdr >> data.outQuadTLinReply();
                                                            break;

                                                        case RBIC1::OUTLINTQUAD_REPLY:
                                                            dcdr >> data.outLinTQuadReply();
                                                            break;

                                                        case RBIC1::OUTQUADTQUAD_REPLY:
                                                            dcdr >> data.outQuadTQuadReply();
                                                            break;

                                                        case RBIC1::ZMD31050_CAL1_REPLY:
                                                            dcdr >> data.zmd31050Cal1Reply();
                                                            break;

                                                        case RBIC1::ZMD31050_SIM1_REPLY:
                                                            dcdr >> data.zmd31050Sim1Reply();
                                                            break;

                                                        case RBIC1::DLLVERSION_REPLY:
                                                            dcdr >> data.dllVersionReply();
                                                            break;

                                                        case RBIC1::GETMESSAGE_REPLY:
                                                            dcdr >> data.getMessageReply();
                                                            break;

                            default:
                                break;
                        }
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}



template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::GenericRequest& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.requestId(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.request(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GenericRequest& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.requestId()
        << eprosima::fastcdr::MemberId(1) << data.request()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::GenericRequest& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.requestId();
                                            break;

                                        case 1:
                                                dcdr >> data.request();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GenericRequest& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




template<>
eProsima_user_DllExport size_t calculate_serialized_size(
        eprosima::fastcdr::CdrSizeCalculator& calculator,
        const RBIC1::GenericReply& data,
        size_t& current_alignment)
{
    using namespace RBIC1;

    static_cast<void>(data);

    eprosima::fastcdr::EncodingAlgorithmFlag previous_encoding = calculator.get_encoding();
    size_t calculated_size {calculator.begin_calculate_type_serialized_size(
                                eprosima::fastcdr::CdrVersion::XCDRv2 == calculator.get_cdr_version() ?
                                eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
                                eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
                                current_alignment)};


        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(0),
                data.requestId(), current_alignment);

        calculated_size += calculator.calculate_member_serialized_size(eprosima::fastcdr::MemberId(1),
                data.reply(), current_alignment);


    calculated_size += calculator.end_calculate_type_serialized_size(previous_encoding, current_alignment);

    return calculated_size;
}

template<>
eProsima_user_DllExport void serialize(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GenericReply& data)
{
    using namespace RBIC1;

    eprosima::fastcdr::Cdr::state current_state(scdr);
    scdr.begin_serialize_type(current_state,
            eprosima::fastcdr::CdrVersion::XCDRv2 == scdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR);

    scdr
        << eprosima::fastcdr::MemberId(0) << data.requestId()
        << eprosima::fastcdr::MemberId(1) << data.reply()
;
    scdr.end_serialize_type(current_state);
}

template<>
eProsima_user_DllExport void deserialize(
        eprosima::fastcdr::Cdr& cdr,
        RBIC1::GenericReply& data)
{
    using namespace RBIC1;

    cdr.deserialize_type(eprosima::fastcdr::CdrVersion::XCDRv2 == cdr.get_cdr_version() ?
            eprosima::fastcdr::EncodingAlgorithmFlag::DELIMIT_CDR2 :
            eprosima::fastcdr::EncodingAlgorithmFlag::PLAIN_CDR,
            [&data](eprosima::fastcdr::Cdr& dcdr, const eprosima::fastcdr::MemberId& mid) -> bool
            {
                bool ret_value = true;
                switch (mid.id)
                {
                                        case 0:
                                                dcdr >> data.requestId();
                                            break;

                                        case 1:
                                                dcdr >> data.reply();
                                            break;

                    default:
                        ret_value = false;
                        break;
                }
                return ret_value;
            });
}

void serialize_key(
        eprosima::fastcdr::Cdr& scdr,
        const RBIC1::GenericReply& data)
{
    using namespace RBIC1;

    static_cast<void>(scdr);
    static_cast<void>(data);
}




} // namespace fastcdr
} // namespace eprosima

#endif // _FAST_DDS_GENERATED_RBIC1_RBIC1CDRAUX_IPP_

